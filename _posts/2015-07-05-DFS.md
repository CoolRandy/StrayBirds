---
layout: post
title: 深度优先搜索算法实现
category: 技术
comments: false
---
##DFS基本思想描述：
首先访问某一个起始顶点v，然后有v出发，访问与v邻接且未被访问的任意结点w1，再访问与w1邻接且未被访问的任一顶点w2，...重复上述过程。当不能继续向下访问时，依次会退到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该顶点继续上述搜索过程，直到途中所有顶点均被访问过为止。
##算法导论中的伪码描述：
```c
  //u 为 v 的先辈或父母。
  DFS(G)
  1  for each vertex u ∈ V [G]
  2       do color[u] ← WHITE
  3          π[u] ← NIL  
  //第1-3行，把所有顶点置为白色，所有π 域被初始化为NIL, π[u]即为u的前驱顶点，初始化
  4  time ← 0       //复位时间计数器
  5  for each vertex u ∈ V [G]
  6       do if color[u] = WHITE
  7             then DFS-VISIT(u)  //调用DFS-VISIT访问u，u成为深度优先森林中一棵新的树
      //第5-7行，依次检索V中的顶点，发现白色顶点时，调用DFS-VISIT访问该顶点。
      //每个顶点u 都对应于一个发现时刻d[u]和一个完成时刻f[u]。
  DFS-VISIT(u)
  1  color[u] ← GRAY            //u 开始时被发现，置为灰色
  2  time ← time +1             //time 递增
  3  d[u] ← time                   //记录u被发现的时间
  4  for each v ∈ Adj[u]   //检查并访问 u 的每一个邻接点 v  Adj[u]b表示u所有的邻接点
  5       do if color[v] = WHITE            //如果v 为白色，则递归访问v。
  6             then π[v] ← u                   //置u为 v的先辈
  7                         DFS-VISIT(v)        //递归深度，访问邻结点v
  8  color[u] ← BLACK         //u 置为黑色，表示u及其邻接点都已访问完成
  9  f [u] ← time ← time +1  //访问完成时间记录在f[u]中。
  //完
  第1-3行，5-7行循环占用时间为O（V），此不包括调用DFS-VISIT的时间。
      对于每个顶点v(-V，过程DFS-VISIT仅被调用1次，因为只有对白色顶点才会调用此过程。
  第4-7行，执行时间为O（E）。
  因此，总的执行时间为O(V+E)。
```
##DFS的c代码实现
```c
  #include<stdio.h>
  #include<stdlib.h>
  #include<conio.h>
  
  #define MaxNum 10
  
  struct enode					/*定义表点结结构*/
  {
  	int adjvex;      //对应的是结点的序号0,1,2。。。
  	struct enode* next;
  }enode;
  
  struct vnode					/*定义顶点结点结构*/
  {
  	char vertex;
  	struct enode* firstedge;
  }vnode;
  
  struct ALGraph					/*定义图结构*/
  {
  	struct vnode adjlist[MaxNum];//存储的是结点的名称如v1，v2。。。
  	int n, e;
  
  }ALGraph;
  
  int locate_vex(struct ALGraph*G, char vex)//定位定点vex在有向图中G中的序号位置
  {
  	int i;
  	for(i = 0; i < G->n; i++)
  	{
  		if(G->adjlist[i].vertex == vex)
  			return i;
  	}
  
  }
  
  void createGraph(struct ALGraph* G)
  {
  	int i, j, k;
  	char vex1, vex2;
  	struct enode * s;
  
  	printf("\n请输入有向图的顶点名称：");
  
  	for(i = 0; i < G->n; i++)
  	{
  		scanf_s("\n%c", &G->adjlist[i].vertex);
  		G->adjlist[i].firstedge = NULL;
  	}
  
  	printf("\n请输入有向图的每条弧的弧尾顶点和弧头顶点名称：");
  	for (k = 0; k < G->e; k++)
  	{
  		printf("\n请输入第%d条弧的弧尾顶点名称：", k+1);
  		scanf_s("\n%c", &vex1);
  		printf("\n请输入第%d条弧的弧头顶点名称：", k+1);
  		scanf_s("\n%c", &vex2);
  
  		i = locate_vex(G, vex1);
  		j = locate_vex(G, vex2);
  
  		s = (struct enode*)malloc(sizeof(struct enode));
  		s->adjvex = j;
  		s->next = G->adjlist[i].firstedge;
  		G->adjlist[i].firstedge = s;
  	}
  }
  
  
  void outGraph(struct ALGraph* G)//输出图结构
  {
  	int i, j;
  	struct enode* s;
  
  	printf("\n\n有向图有%d个顶点", G->n);
  	for (int i = 0; i < G->n; i++)
  	{
  		printf("%c", G->adjlist[i].vertex);
  	}
  	printf("\n\n有向图有%d个弧", G->e);
  	for (int i = 0; i < G->n; i++)
  	{
  		printf("\n%c->", G->adjlist[i].vertex);
  		s = G->adjlist[i].firstedge;
  		while (s)
  		{
  			printf("%c ", G->adjlist[s->adjvex].vertex);
  			s = s->next;
  		}
  	}
  }
  
  int visited[MaxNum];
  
  void DFS(struct ALGraph *G, int i)//从n个结点中任意选取一个开始遍历
  {
  	struct enode *p;
  	printf("访问顶点%c", G->adjlist[i].vertex);
  	visited[i] = 1;
  	p = G->adjlist[i].firstedge;
  	while(p)
  	{
  		if(!visited[p->adjvex])
  		{
  			DFS(G, p->adjvex);
  		}
  		p = p->next;
  	}
  }
  
  void DFSTraverse(struct ALGraph *G)
  {
  	int i;
  	for(i = 0; i < G->n; i++)
  	{
  		visited[i] = 0;
  	}
  	printf("\n");
  
  	for(i = 0; i < G->n; i++)
  	{
  		if(!visited[i])
  		{
  			DFS(G, i);
  		}
  	}
  }
  
  void main()
  {
  	struct ALGraph alg;
  	printf("\n有向图存储结构。。。");
  	printf("\n请输入有向图的顶点数目：");
  	scanf_s("%d",&alg.n);
  	printf("\n请输入有向图的弧数目：");
  	scanf_s("%d",&alg.e);
  	createGraph(&alg);
  	outGraph(&alg);
  	DFSTraverse(&alg);
  	getch();
  }
```
