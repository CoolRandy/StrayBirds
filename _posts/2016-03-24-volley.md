---
layout: post
title: Volley源码解析
category: 技术
comments: true
---

# Volley框架概述

## Volley总体设计图
![Volley总体设计图][1]

Volley的总体设计思路很清晰：主要通过两种不同的分发线程(CacheDispacher和NetworkDispatcher)不断的从请求队列(RequestQueue)中获取请求，这些请求都是继承于Request，可以自己根据实际需求进行定制，后面会提到；然后根据是否已缓存来调用Cache或Network两类数据获取接口之一，从内存或服务器获取到请求的数据，最后再由ResponseDelivery去做结果分发和回调处理。

## Volley的主要特点

主要从优点和缺点两个角度来阐述
优点：这里参考StackOverflow上的介绍
> 1.The networking part isn’t just for images. Volley is intended to be an integral part of your backend. For a fresh project based off of a simple REST service, this could be a big win.
2.NetworkImageView is more aggressive about request cleanup than Picasso, and more conservative in its GC usage patterns.
3.NetworkImageView relies exclusively on strong memory references, and cleans up all request data as soon as a new request is made for an ImageView, or as soon as that ImageView moves offscreen.
4.Performance. This post won’t evaluate this claim, but they’ve clearly taken some care to be judicious in their memory usage patterns. Volley also makes an effort to batch callbacks to the main thread to reduce context switching.
5.Volley apparently has futures, too. Check out RequestFuture if you’re interested.
6.If you’re dealing with high-resolution compressed images, Volley is the only solution here that works well.
7.Volley can be used with Okhttp (New ver of Okhttp supports NIO for better performance )
8.Volley plays nice with the Activity life cycle.

扩展性强。Volley大多是基于接口的设计，可配置性强
一定程度符合Http规范，包括返回ResponseCode(2xx, 3xx, 4xx, 5xx)的处理，请求头的处理，缓存机制的支持等。并支持重试及优先级定义。
默认Android 2.3及以上基于HttpURLConnection，2.3以下基于HttpClient实现
提供简便的图片加载工具
缺点(存在的问题)：以下问题不支持，部分已解决
> 1. Multipart Requests (Solution: [https://github.com/vinaysshenoy/enhanced-volley][2]) 
> 2. status code 201 is taken as an error, Status code from 200 to 207 are successful responses now.(Fixed: [https://github.com/Vinayrraj/CustomVolley][3])  Update: in latest release Google volley the 2XX Status codes bug is fixed now!
> 3. it's less documented but many of the people supporting this volley in github, java like documentation can be found here [http://files.evancharlton.com/volley-docs/][4]
> 4. To solve/change Redirect Policy of Volley Framework use Volley with OkHTTP (CommonsWare mentioned above)

Volley不适用于处理大文件的上传和下载，对此官方建议如下：
> Volley is not suitable for large download or streaming operations, since **Volley holds all responses in memory during parsing.**
For large download operations,consider using an alternative like DownloadManager.
- 关于Volley中的图片加载
    在分析具体的实现方式之前，首先来看一下ImageLoader实现图片加载的特点：
> 1、可以设置自定义的ImageCache，这里ImageCache是个接口，后面会详细说明。可以是内存缓存，也可以是磁盘缓存，将获取的图片缓存起来，可以复用以减少网络请求。默认源码里只实现了L2级缓存，没有实现L1级缓存，但是可以自己实现，后面也会具体讲解
2、可以定义图片请求过程中显示的图片和请求失败后显示的图片
3、对于相同请求（相同地址，相同大小），只发送一个，实现过滤重复请求

对于Volley中存在的三种图片加载方式，这里我们首先来分析采用ImageLoader来加载图片的方式：
为了辅助源码理解，这里先讲一下ImageLaoder的基本使用：
其过程分为四步：1、创建一个RequestQueue对象   2、创建一个ImageLoader对象   3、获取一个ImageListener对象  4、调用ImageLoader的get方法加载网络上的图片

这里直接将4步代码全部贴上：

```java
//创建请求队列
RequestQueue mQueue = Volley.newRequestQueue(context);
//新建ImageLoader对象
ImageLoader imageLoader = new ImageLoader(mQueue, new ImageCache() {  
    @Override  
    public void putBitmap(String url, Bitmap bitmap) {  
    }  
  
    @Override  
    public Bitmap getBitmap(String url) {  
        return null;  
    }  
});  
//获取ImageListener对象
ImageListener listener = ImageLoader.getImageListener(imageView,  
        R.drawable.default_image, R.drawable.failed_image);  
//调用get方法加载
imageLoader.get("http://img.my.csdn.net/uploads/201404/13/1397393290_5765.jpeg", listener);  
//也可指定图片大小
imageLoader.get("http://img.my.csdn.net/uploads/201404/13/1397393290_5765.jpeg",  
                listener, 200, 200);  
```

那接下来我们从源码实现的角度来分析：
首先来看一下ImageLoader内部定义的几个属性：

```java
    //RequestQueue for dispatching ImageRequests onto. 
    //分发ImageRequest的请求队列
    private final RequestQueue mRequestQueue;

    //Amount of time to wait after first response arrives before delivering all responses.
    //在传送所有响应之前，第一个响应到达之后的等待时间
    private int mBatchResponseDelayMs = 100;

    //The cache implementation to be used as an L1 cache before calling into volley. 用于L1级缓存的cache接口
    private final ImageCache mCache;

    //HashMap of Cache keys -> BatchedImageRequest used to track in-flight requests so that we can coalesce multiple requests to the same URL into a single network request.缓存的key的hash值，也即请求url的hash值作为map中的key，BatchedImageRequest就是用来保证如果我们对同一个url重复发送了多个请求，可以将其过滤掉，合为一个网络请求
    private final HashMap<String, BatchedImageRequest> mInFlightRequests =
    new HashMap<String, BatchedImageRequest>();

    //HashMap of the currently pending responses (waiting to be delivered).当前挂起响应的map  等待被传输
    private final HashMap<String, BatchedImageRequest> mBatchedResponses =
            new HashMap<String, BatchedImageRequest>();

    // Handler to the main thread. 主线程的handler
    private final Handler mHandler = new Handler(Looper.getMainLooper());

    //Runnable for in-flight response delivery.
    private Runnable mRunnable;
```

内部定义了一个用于一级缓存的Cache接口：

```java
    /**
     * Constructs a new ImageLoader.
     * @param queue The RequestQueue to use for making image requests.
     * @param imageCache The cache to use as an L1 cache.
     */
    public ImageLoader(RequestQueue queue, ImageCache imageCache) {
        mRequestQueue = queue;
        mCache = imageCache;
    }
```

前面步骤2就是采用该构造方法创建ImageLoader对象
获取ImageListener对象

```java
    /**
     * The default implementation of ImageListener which handles basic functionality
     * of showing a default image until the network response is received, at which point
     * it will switch to either the actual image or the error image.
     * @param view The imageView that the listener is associated with.
     * @param defaultImageResId Default image resource ID to use, or 0 if it doesn't exist.
     * @param errorImageResId Error image resource ID to use, or 0 if it doesn't exist.
     */
    public static ImageListener getImageListener(final ImageView view,
            final int defaultImageResId, final int errorImageResId) {
        return new ImageListener() {
            @Override
            public void onErrorResponse(VolleyError error) {
                if (errorImageResId != 0) {
                    view.setImageResource(errorImageResId);
                }
            }

            @Override
            public void onResponse(ImageContainer response, boolean isImmediate) {
                if (response.getBitmap() != null) {
                    view.setImageBitmap(response.getBitmap());
                } else if (defaultImageResId != 0) {
                    view.setImageResource(defaultImageResId);
                }
            }
        };
    }
```

这里内部直接返回新建的ImageListenr对象，重写的回调方法分别对请求成功和失败的情况进行处理，请求成功后会会传回ImageContainer对象，通过该对象可以获取bitmap，从而直接将bitmap设置在ImageView控件中。

内部又定义了一个ImageContainer类，包含图片请求的所有数据：bitmap、imageListener、cacheKey和requestUrl
这里的核心类就是get方法，内部实现了三个get方法，最终都会调用如下方法：

```java
public ImageContainer get(String requestUrl, ImageListener imageListener,
            int maxWidth, int maxHeight, ScaleType scaleType) {

        // only fulfill requests that were initiated from the main thread.
        throwIfNotOnMainThread();

        final String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight, scaleType);

        // Try to look up the request in the cache of remote images.
        Bitmap cachedBitmap = mCache.getBitmap(cacheKey);
        if (cachedBitmap != null) {
            // Return the cached bitmap.
            ImageContainer container = new ImageContainer(cachedBitmap, requestUrl, null, null);
            imageListener.onResponse(container, true);
            return container;
        }

        // The bitmap did not exist in the cache, fetch it!
        ImageContainer imageContainer =
                new ImageContainer(null, requestUrl, cacheKey, imageListener);

        // Update the caller to let them know that they should use the default bitmap.
        imageListener.onResponse(imageContainer, true);

        // Check to see if a request is already in-flight. 判断是否已经发送了该请求
        BatchedImageRequest request = mInFlightRequests.get(cacheKey);
        if (request != null) {
            // If it is, add this request to the list of listeners.
            request.addContainer(imageContainer);
            return imageContainer;
        }

        // The request is not already in flight. Send the new request to the network and
        // track it.
        Request<Bitmap> newRequest = makeImageRequest(requestUrl, maxWidth, maxHeight, scaleType,
                cacheKey);

        mRequestQueue.add(newRequest);
        mInFlightRequests.put(cacheKey,
                new BatchedImageRequest(newRequest, imageContainer));
        return imageContainer;
    }
    
    protected Request<Bitmap> makeImageRequest(String requestUrl, int maxWidth, int maxHeight,
            ScaleType scaleType, final String cacheKey) {
        return new ImageRequest(requestUrl, new Listener<Bitmap>() {
            @Override
            public void onResponse(Bitmap response) {
                onGetImageSuccess(cacheKey, response);
            }
        }, maxWidth, maxHeight, scaleType, Config.RGB_565, new ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError error) {
                onGetImageError(cacheKey, error);
            }
        });
    }
    
    //BatchedImageRequest的具体实现
    private class BatchedImageRequest {
        /** The request being tracked */
        private final Request<?> mRequest;

        /** The result of the request being tracked by this item */
        private Bitmap mResponseBitmap;

        /** Error if one occurred for this response */
        private VolleyError mError;

        /** List of all of the active ImageContainers that are interested in the request */
        private final LinkedList<ImageContainer> mContainers = new LinkedList<ImageContainer>();

        /**
         * Constructs a new BatchedImageRequest object
         * @param request The request being tracked
         * @param container The ImageContainer of the person who initiated the request.
         */
        public BatchedImageRequest(Request<?> request, ImageContainer container) {
            mRequest = request;
            mContainers.add(container);
        }

        /**
         * Set the error for this response
         */
        public void setError(VolleyError error) {
            mError = error;
        }

        /**
         * Get the error for this response
         */
        public VolleyError getError() {
            return mError;
        }

        /**
         * Adds another ImageContainer to the list of those interested in the results of
         * the request.
         */
        public void addContainer(ImageContainer container) {
            mContainers.add(container);
        }

        /**
         * Detatches the bitmap container from the request and cancels the request if no one is
         * left listening.
         * @param container The container to remove from the list
         * @return True if the request was canceled, false otherwise.
         */
        public boolean removeContainerAndCancelIfNecessary(ImageContainer container) {
            mContainers.remove(container);
            if (mContainers.size() == 0) {
                mRequest.cancel();
                return true;
            }
            return false;
        }
    }
```

这里便处理了重复请求的过滤处理，具体执行流程分析如下：
1、判断是否在UI线程中，否则抛异常
2、根据请求url获取其存到缓存中的键值cacheKey
3、首先从cacheKey中判断是否已缓存中已存在当前的请求，如果存在，则采用缓存中的bitmap构建ImageContainer对象，并调用ImageListenr的onResponse回调方法，然后设置bitmap到inageview中
4、如果不存在，首先传入bitmap对象为null来构建ImageContainer对象，然后调用ImageListenr的onResponse回调方法，显示默认的bitmap
5、接着判断该url的请求是否已经发送，即in-flight,若request不为空，说明已发送，则将imageContainer对象添加到**监听队列**中
6、如果没有发送，即首次发送，则将请求添加到**请求队列**中

至此，便详细分析了整个加载图片的过程，既过滤了重复发送，又定义了图片显示，还有就是对于内存缓存，即一级缓存可以参照UIL的实现进行定义，这里附上一个简单的实现：

```java
public class BitmapCache implements ImageLoader.ImageCache{

    private LruCache<String, Bitmap> mCache;

    private final String TAG = this.getClass().getSimpleName();

    public BitmapCache() {
        int maxSize = 10 * 1024 * 1024; // 4MiB
        mCache = new LruCache<String, Bitmap>(maxSize){
            @Override
            protected int sizeOf(String key, Bitmap value) {

                return value.getRowBytes() * value.getHeight();
            }
        };
    }

    @Override
    public void putBitmap(String url, Bitmap bitmap) {
        Log.v(TAG, "Added item to Mem Cache");
        mCache.put(url, bitmap);
    }

    @Override
    public Bitmap getBitmap(String url) {
        Log.v(TAG, "Retrieved item from Mem Cache");
        return mCache.get(url);
    }
}
```

以上便是对于ImageLoader的图片加载的分析过程

  [1]: https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/design.png
  [2]: https://github.com/vinaysshenoy/enhanced-volley
  [3]: https://github.com/Vinayrraj/CustomVolley
  [4]: http://files.evancharlton.com/volley-docs/
